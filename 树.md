```
哈夫曼编码
克鲁斯卡尔算法与普林算法分析
```



* 不包含简单回路的连通图称为树
* 通过**深度优先捜索**或**宽度优先搜索**，可以系统地遍历图的顶点，构造出一棵包括每个顶点的树。通过深度优先搜索来探索图的顶点，也称为**回溯**，允许系统地搜索各种问题的解。
* 可以给树的边赋权值来为许多问题建立模型。

##### 树的概述

* 树的一种特殊类型的图。
* **树是没有简单回路的连通无向图**。
* 任何一个不包含简单回路的连通图都是树。不含简单回路但不一定连通的图称为**森林**，而且具有这样的性质：它们的每个连通分支都是树。
  * 森林的连通分支是联通的， 森林不含简单回路。s.t 它们的每个连通分支都是树
* 通常把树定义成具有在每对顶点之间存在唯一简单通路性质的无向图。
* **一个无向图是树当且仅当在它的每对顶点之间存在唯一简单通路。**
* 在树的许多应用中，指定树的一个特殊顶点作为**根**。一旦规定了根，就可以给每条边指定 方向。因为从根到图中每个顶点存在唯一通路, 所以指定每条边是离开根的方向。因此，*树与它的根一起产生一个有向图* ，称为**有根树**。
* **有根树是指定一个顶点作为根并且每条边的方向都离开根的树。**
  * 子节点表示法（只存在父节点到子节点的链接）
  * 对根的不同选择会导致产生不同的有根树。
* 树的顶点若没有孩子则称为**树叶**。有孩子的顶点 称为**内点**。根是内点，除非它是图中唯一的顶点，在这种情况下，它是树叶。
* 若a是树中的顶点，则以**a为根的子树**是由a和a的后代以及这些顶点所关联的边所组成的该**树的子图**。
* 若有根树的每个内点都有不超过m个孩子，则称它为**m叉树**。若该树的每个内点都恰好有m个孩子，则称它为**满m叉树**。把m = 2的m叉树称为**二叉树**。

* **有序根树** 是把每个内点的孩子都排序的有根树。画有序根树时，以从左向右的顺序来显示每个内点的孩子。注意在常规方式下有根树的表示将确定它的边的一种顺序。我们将在画图时使用边的这种顺序，但不明确地指出有根树是有序的。

* 在有序二叉树（通常只称为二叉树）中，若一个内点有2个孩子，则第一个孩子称为**左子**而第 二个孩子称为**右子**。以一个顶点的左子为根的树称为该顶点的**左子树**，而以一个顶点的右子为 根的树称为该顶点的**右子树**。对某些应用来说，二叉树的每个非根顶点都指定为其父母的右子或左子。即使当某些顶点仅有一个孩子也这样做。具体指定方式视需要而定。

---

##### 树的性质

* 带有 n 个顶点的树含有 $n-1$条边
* 带有 i 个内点的满 m 叉树含有 $n = mi + 1$个顶点。
  * 除了根之外的每个顶点都是内点的孩子。因为每个内点有m个孩子，所以在树中除了根之外还有$m*i$个顶点。因此，该树含有$n=mi+1$个顶点。
* —个满 m 叉树若, 设 i 是该树的内点数, l是树叶数, n 为顶点数。
  * $n = mi + 1; l = n - i;$
  * n 个顶点，则有 $i = (n -1)/m$ 个内点和 $l = [(m -1)n + 1] /m$ 个树叶
    * $i = (n - 1)/m; l = n - (n-1)/m = [(m -1)n + 1] /m $
  *  $i$ 个内点，则有 $n = m*i + 1$个顶点和 $ l = m * i + 1 - i = (m-1)i + 1$ 个树叶；
  *  $l$ 个树叶， 则有 $n = (lm - 1)/(m-1)$个顶点和 $i = n-l = (lm-1)/(m-1) - l = (l-1)/(m-1)$个内点。
* **平衡的m叉树**   经常需要使用这样的有根树，它们是“平衡的"，所以在 *每个顶点的子树都包含大约相同长度的通路* 。
  * 在有根树中**顶点的层**是从根到这个顶点的唯一通路的长度。根的层定义为0。
  * **有根树的高度**就是顶点层数的最大值。
  * 换句话说，有根树的层数是从根到任意顶点的最长通路的长度。
* 若一棵高度为 h 的 m 叉树的所有树叶都在 h 层或 h-1 层，则这棵**树是平衡的**。
* 在高度为 h 的  m 叉树中至多有个 $m^h$ 树叶。
* 若一棵高度为 h 的 m 叉树带有 $l$ 个树叶，则 $h \ge log_ml$.  若这棵m叉树是满的和平 衡的，则 $ h =  \lceil log_ml\rceil $（这里使用向上取整函数。$\lceil x \rceil$是大于或等于 x 的最小整数）。
  * $l \le m^h; log_ml \le h; h \in N; h \ge \lceil log_ml \rceil; $
  * 假定这棵树是平衡的。于是每个树叶都在 h 层或 h - 1层上，而且因为树的高度为  h ,所以在 h 层至少有一个树叶。所以必然有超过况 $m ^{h-1}$个树叶,因为 $l \le m^h$, 所以 $m^{h-1} \lt l \le m^h; {h-1} \lt log_ml \le \rceil log_ml \rceil$.

---

##### 树的应用

* 运用树来讨论三个问题。
  * 应当如何对列表里的元素进行排序，以便可 以容易地找到元素的位置
  * 为了在某种类型的一组对象里找出带有某种性质的对象，应当做出一系列什么样的决策
  * 应当如何用位串来有效地编码一组字符
*  **二叉捜索树**   在列表里搜索一些元素。主要目标是实现一个搜索算法， 当元素都完全排序时，这个算法有效地找出元素。这个任务可以通过使用二叉搜索树来完成， 二叉搜索树是一种二叉树. 其中任何顶点的每个孩子都指定为右子或左子，没有顶点有超过一个的右子或左子，而且 *每个顶点都用一个关键字来标记，这个关键字是各元素中的一个* 。另外，这样指定顶点的关键字，使得 *顶点的关键字不仅大于它的左子树里的所有顶点的关键字， 而且小于它的右子树里的所有顶点的关键字*。

* 从只包含一个顶点（即根）的树开始。指定列表中第一个元素作为这个根的关键字。为了添加新的元素，首先比较它与已经在树中的顶点 的关键字，从根开始，若这个**元素小于所比较顶点的关键字而且这个顶点有左子，则向左移动， 若这个元素大于所比较顶点的关键字而且这个顶点有右子，则向右移动**。当这个元素小于所比 较顶点的关键字而且这个顶点没有左子时，就插入以这个元素作为关键字的一个新顶点，并把 新顶点作为这个顶点的左子。同理，当这个元素大于所比较顶点的关键字而且这个顶点没有右子时，就插入以这个元素作为关键字的一个新顶点，并把新顶点作为这个顶点的右子。

  ```
  在二叉搜索树中査找或添加一个元素 
  procedure insertion (T:二叉搜索树，x:元素) 
  v := T的根
  
  while v != null 并且 label (v) != x
      if x < label (v) then
          if v 的左子 != null then v := v的左子
          else添加新顶点作为 v 的左子并且设置 v := null
      else
          if v的右子 != null then v := v的右子
          else 给 T 添加新顶点作为 v 的右子并且设置 v:=null 
  if T的根 = null then给树添加顶点 v 并且用 x 标记它 
  else if v为null或 label (v) != x then 用x标记新顶点v 
  return v｛ v=x 的位置 ｝
  ```

* 若二叉捜索树是平衡的，则确定一个元素的位置或者添加一个元素所需要的比较次数不超过$\lceil log_2n \rceil$次。当给二叉捜索树添加一些元素时， 该树可能变得不平衡。



* 有根树可以用来为一系列决策求解问题建立模型。例如，二叉捜索树可以用来基于一系列比较来找出元素的位置，其中每次比较都说明是否已经找到了元素的位置，或者是否应当向右或向左进入子树。其中每个内点都对应着一次决策，这些顶点的子树都对应着该决策的每种可 能结果，这样的有根树称为**决策树**。*问题的可能解对应着这个有根树中通向树叶的通路*。

* **基于比较的排序算法的复杂度**  已经开发了许多不同的排序算法。为了确定一个具体的排序算法是否有效，就要确定这个算法的复杂度。用决策树作为模型，可以求出基于二元比较的 排序算法的最坏情形复杂度的下界。

  * 可以用决策树为排序算法建立模型并且确定对这些算法的最坏情形复杂度的估计。注意给定 n 个元素，这些元素有 $n!$ 种可能的排序，因为这些元素的 $n!$ 种排列中的每一个都可以是正确的顺序。最常用的排序算法都基于**二元比较**，即一次比较两个元素。每次这样的比较都缩小了可能的顺序集合。而且，基于二元比较的排序算法可以表示成二叉决策树，其中每个内点表示两个元素的一次比较。每个树叶表示 n 个元素的 $n!$种排列中的一种。

    ![image-20200419150430405](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20200419150430405.png)	

  * 基于二元比较的排序的复杂度是用二元比较的次数来度量的。排序有n个元素的列表所需要的最多比较次数就给岀了这个算法的最坏情形复杂度。所用的最多比较次数等于表示这个排序过程的决策树里的最长通路长度。换句话说，所需要的最多比较次数等于这个决策树的高度。因为带  $n!$ 个树叶的二叉树的高度至少是「 $log{n!}$ ］，至少需要「 $log{n!}$ ］次比较。

* **基于二元比较的排序算法至少需要「 $log{n!}$ ］次比较。**

*  **基于二元比较的排序算法排序**n**个元素所用的比较次数是 $\Omega(nlogn)$。**

  * 基于二元比较的排序算法在最坏情形下使用 $\Omega(nlogn)$ 次比较来排序 n 个元素是最优的，其他这类算法都没有更好的最坏情形复杂度，在这个意义下归并排序算法是最优的。

* **前缀码**
  * 考虑用不同长度的位串来编码字母。较短的位串用来编码出现较频繁的字母，较长的位串应当用来编码不经常出现的字母。当用可变长的位数来给字母编码时，就必须用某种方法来确 定每个字母的位在何处开始和结束。
  * 为了保证没有位串对应着多个字母的序列，可以令一个字母的位串永远不出现在另一个字母的位串的开头部分。具有这个性质的编码称为**前缀码**。
  * 前缀码可以用二叉树来表示，其中字符是树中树叶的标记。树的边也被标记，使得通向左子的边标记为0而通向右子的边标记为1。用 来编码一个字符的位串是在从根到以这个字符作为标记的树叶的唯一 通路上标记的序列。
  * 可以从任何二叉树来构造一个前缀码，其中每个内点的左边都用0标记，而右边都用1标 记，树叶都用字符标记。字符都用从根到这个树叶的唯一通路中的边的标记所组成的位串来编码。
  * **哈夫曼编码**   给定符号及其频率，目标是构造一个有根的二叉树，其中符号是树叶的标记。算法从只含有一个顶点的一些树构成的森林开始，其中每个顶点有一个符号作为标记，并且这个顶点的权就等于所标记符号的频率。在每一步，都把具有最小总权值的两个树组合成一个单独的树，方法是引入一个新的根，把具有较大的权的树作为左子树，把具 有较小的权的树作为右子树。另外，把这个树的两个子树的权之和作为这个树的总权值。(虽 然可以规定在具有相同的权的树之间进行选择以打破平局的过程，但是这里将不具体指定这样 的过程。)当构造出了一个树，即森林缩小为单个树时，算法就停止。
* **博弈树**  可以用树来分析某些类型的游戏，比如圈叉游戏、取石子游戏、跳棋和象棋。在每一种游戏中，两个选手轮流进行移动。每个选手知道另一个选手的移动并且游戏不存在偶然因素。使用博弈树为这样的游戏建立模型，这些树的顶点表示当游戏进行时游戏所处的局面，边表示在 这些局面之间合乎规则的移动。由于博弈树常常很大，所以通过用同一个顶点表示所有对称的 局面来简化博弈树。但是，如果一个游戏的不同移动序列导致同一个局面，则可以用不同的顶 点来表示这个局面。根表示起始的局面。通常的约定是用方框表示偶数层的顶点并且用圆圈表 示奇数层的顶点。当游戏处在偶数层顶点所表示的局面时，就轮到第一个选手移动。当游戏处 在奇数层顶点所表示的局面时，就轮到第二个选手移动。博弈树所表示的游戏可以永远不结 束，比如进入了无穷循环，因此博弈树可以是无穷的，但是对于大多数游戏来说，都存在一些 规则导致有穷的博弈树。

* 可以用某种方式递归地定义博弈树中所有顶点的值，使得可以确定当两个选手都遵循最优策略时这个游戏的结果。所谓**策略**，就意味着一组规则，这些规则说明一个选手如何移动来赢得游戏。第一个选手的最优策略就是把这个选手的得分最大化的策略，第二个选手的最优策略就是把这个得分最小化的策略。现在递归地定义顶点的值。

* 博弈树中顶点的值递归地定义为：
  * 一个树叶的值是当游戏在这个树叶所表示的局面里终止时第一个选手的得分。
  * 偶数层内点的值是这个内点的孩子的最大值，奇数层内点的值是这个内点的孩子的最小值。
* 使第一个选手移动到具有最大值的孩子所表示的局面并且第二个选手移动到具有最小值的孩子所表示的局面的策略称为**最小最大策略**。当两个选手都遵循最小最大策略时，通过计算树根的有就可以确定谁将赢得游戏，这个值称为**树的值**。
* 博弈树顶点的值说明，如果两个选手都遵循最小最大策略并且从博弈树的某一个顶点所表示的局面开始进行游戏，则这个顶点的值表明第一个选手的得分。

---

##### 树的遍历

* 有序根树常常用来保存信息。掌握一些访问有序根树的每个顶点以存取数据的算法是非常必要的。
* 遍历有序根树所有顶点的过程，都依赖于孩子的顺序。在有序根树中，一个内点的孩子从左向右地显示在表示这些有向图的图形中。
* **通用地址系统**
  1. 用整数 0 标记根。然后用1, 2, 3,…，k 从左向右标记它的 k 个孩子（在1层上）。
  2. 对在n层上带标记A的每个顶点v,按照从左向右画出它的$k_v$个孩子的顺序，用$A.1, A.2,..., A.k$ 标记它的$k_v$个孩子。
* 可以利用顶点在通用地址系统里标记的字典顺序将这些顶点完全排序。若存在满足$x_1 = y_1, x_2 = y_2, ..., x_{i-1} = y_{i-1}$, 且 $x_i \lt y_i$;  或者若 $n \lt m$,  并且对 $i = 1, 2,3, ..., n$ 来说 $x_i = y_i$ 那么标记$x_1, x_2, ..., x_n$的顶点就小于标记$y_1, y_2, ..., y_n$的顶点。
* 系统地访问有序根树每个顶点的过程称为遍历算法。下面描述三个最常用的算法：前序遍 历、中序遍历和后序遍历。这些算法都可以递归地定义。
* T是带根 r 的有序根树。若 T 只包含  r，则r是T的**前序遍历**。否则，假定$T_1, T_2, ..., T_n$是 T 的以 r 为根的从左向右的子树。前序遍历首先访问 r . 接着以前序来遍历$T_1$；然后以前序来遍历$T_2$，以此类推，直到以前序遍历了 $T_n$为止。

* 有序根树的前序遍历给出了与利用通用地址系统所得出的顺序相同的顶点顺序。
* 设 T 是带根 r 的有序根树。若T只包含 r ,则 r 是T的**中序遍历**。否则，假定$T_1, T_2, ..., T_n$是T中以r为根的从左向右的子树。中序遍历首先以中序来遍历$T_1 $,然后访问 r, 它接着以中序来遍历$T_2 $,中序遍历$T_3 $,以此类推，直到以中序遍历了 $T_n $为止。
* 设 T 是带根 r 的有序根树。若T只包含 r ,则 r 是T的**后序遍历**。否则，假定$T_1, T_2, ..., T_n$是T中以r为根的从左向右的子树。后序遍历首先以后序来遍历$T_1 $, 它接着以后序来遍历$T_2 $,后序遍历$T_3 $,以此类推，直到以后序遍历了 $T_n $为止， 最后访问 r。

* 有些简易的方法以前序、中序和后序来列出有序根树的顶点。首先从根开始，沿着边移动, 围绕有序根树画一条曲线。

  * 按照前序列出顶点：当曲线第一次经过一个顶点 时，就列出这个顶点。

  * 按照中序列出顶点：当曲线第一次经过一个树叶时，就列出这个树叶，当曲线第二次经过一个内点时就列出这个内点。

  * 按照后序列出顶点：当曲线最后一次经过一个顶点而返回这个顶点的父母时，就列出这个顶点。

    ![image-20200419154602666](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20200419154602666.png)

* **当规定了每个顶点的孩子数时，有序根树的前序遍历和后序遍历都编码了有序根数 的结构**。也就是说，当指定树的前序遍历或者后序遍历所生成的顶点列表和每个顶点的孩子数目时，有序根树是唯一确定的。特别地，前序遍历和后序遍历都编码了有序 m 叉树的结构。然而，当不规定每个顶点的孩子数时，前序遍历和后序遍历都没有编码有序根树的结构。

* 可以用有序树来表示复杂的表达式，比如复合命题、集合的组合，以及算术表达式。

  * 有序根树是自底向上地构造的。
  * 对表示一个表达式的二叉树进行中序遍历，产生原来的表达式，其中元素和运算都是按原有的次序出现. 为了让这样的表达式无二义性，当遇到运算时，就有必要在中序遍历里包含括号。以这种方式获得的带完整括号的表达式称为**中缀形式**。
  * 当以前序遍历表达式的有根树时，就获得它的**前缀形式**。写成前缀形式的表达式称为**波兰记法**。用前缀记法表示的表达式（其中每个运算都有规定的运算对象数）都是无二义性的，所以在这样的表达式中不需要括号。在表达式的前缀形式里，二元运算符在它的两个运算对象之前。因此，可以从右向左地求前缀形式的表达式的值。当遇到一个运算符时，就对在这个运算对象右边紧接着的两 个运算对象来执行相应的运算。另外，当一个运算执行时，就认为结果是新的运算对象。
  * 通过以后序遍历表达式的二叉树，就可以获得它的**后缀形式**。写成后缀形式的表达式称为**逆波兰记法**。用逆波兰记法表示的表达式都是无二义性的，所以不需要括号。在表达式的后缀形式里，二元运算都是在它的两个运算对象之后。所以，为了从一个表达式的后缀形式求它的值，就从左向右地进行，当一个运算符后面跟着两个运算对象时，就执行 这个运算。在一个运算执行之后，这个运算的结果就成为一个新的运算对象。
  * 因为前缀表达式和后缀表达式都是无二义性的，而且不用来回扫描就容易求出它们的值, 所以它们在计算机科学里大量使用。这样的表达式对编译器的构造是特别有用的

---

##### 生成树

* 设G是简单图。G 的**生成树**是包含 G 的每个顶点的 G 的子图。

* 有生成树的简单图必然是连通的，因为在生成树中，任何两个顶点之间都有通路。反过来 也是对的，即每个连通图都有生成树。

* **简单图是连通的当且仅当它有生成树**（可以利用此定理来删除边以构造生成树）

  * 首先，假定简单图G有生成树T包含G的每个顶点。另外，在T的任何两个顶点 之间都有在T中的通路。因为T是G的子图，所以在G的任何两个顶点之间都有通路。因此， G是连通的。

  * 假定G是连通的。若G不是树，则它必然包含简单回路。从这些简单回路中的一个里删除一条边。所得出的子图少了一条边，但是仍然包含G的所有顶点并且是连通的。这个子 图仍然是连通的，因为当两个顶点由包含这条被删除边的通路相连接时，它们被一条不包含这条边的通路相连接。我们可以通过在原来的通路中，在被删除的边的位置，插入一条带有被删 除边的简单的回路构造这样的通路。若这个子图不是树，则它有简单回路，所以像前面那样，删除一个简单回路里的一条边。重复这个过程直到没有简单回路为止。这是可能的，因为在图里只有有穷的边数。当没有简单回路剩下时，这个过程终止。产生一棵树，因为在删除边时这个图保持连通。这棵树是生成树，因为它包含G的每个顶点。

* **深度优先搜索**   

  * 任意选择图中一个顶点作为根。通过依次添加边来形成从这个顶点开始的通路，其中每条新边都与通路上的最后一个顶点以及还不在通路上的一个顶点相关联。继续尽可能地添加边到这条通路。若这条通路经过图的所有顶点，则由这条通路组成的树就是生成树。不过，若这条通路没有经过图中的所有顶点，则必须添加其他的顶点和边。
  * 退到通路中的倒数第二个顶点，若有可能，则形成从这个顶点开始的经过还没有访问过的顶点的通路。若不能这样做，则后退到通路中的另一个顶点，即在通路里后退两个顶 点，然后再试。
  * 重复这个过程，从所访问过的最后一个顶点开始，在通路上一次后退一个顶点，只要有可能就形成新的通路，直到不能添加更多的边为止。因为这个图有有穷的边数并且是连通的，所 以这个过程以产生生成树而告终。在这个算法的一个阶段上通路末端的顶点将是有根树中的树叶，而在其上开始构造一条通路的顶点将是内点。

  * 这个过程的递归本质。另外，注意若图中的顶点是排序的，则当总是选择在该顺序里可用的第一个顶点时，在这个过程的每个阶段上对边的选择就全都是确定的。不过， 将不总是明显地对图的顶点排序。

* 深度优先搜索也称为回溯，因为这个算法返回以前访问过的顶点以便添加边。

* 一个图的深度优先搜索所选择的边称为**树边**。这个图所有其他的边都必然连接一个顶点与这个顶点在树中的祖先或后代。这些边都称为**背边**。

* **深度优先搜索的递归本质**   当执行深度优先搜索的步骤时，当把顶点 v 加入树时说从顶点 v 开始探索，当最后一次回溯回到 v 时说从顶点 v 结束探索。理解算法的递归本质所需要的关键事实是，当加入连接顶点 v 到顶点 w 的边时，在回到 v 完成从 v 的探索之前就结束了从 w 的探索。

  ```
  算法1深度优先搜索
  procedure DFS（G：带顶点v1, v2,..., vn的连通图） 
  	T :=只包含顶点v1的树
      visit（v1）
  procedure visit（v: G 的顶点）
      for v 的每个邻居 w
          if w 既不在 L 中也不在 T 中 then
              加入顶点w和边{v,w}到T 
              visit （w）
  ```

* 现在分析深度优先搜索算法的计算复杂度。关键事实是**对于每个顶点 v 来说，当在搜索中首次遇到顶点 v 时，就调用过程 visit(v) 并且以后不再调用这个过程**。假设G的邻接表是可用的，那么求出与 v 相邻的顶点不需要任何计算。当遵循算法的步骤时，**至多检查每条边两次以确定是否加入这条边及其一个端点到树中**。因此，过程 DFS 用 $O(e)$或 $O(n^2)$ 个步骤来构造一个生成树，其中e和n分别是G的边数和顶点数。（注意一个步骤包括：检査一个顶点是否已在正在构造的树中，如果这个顶点还不在树中，则加入这个顶点和对应的边。 还利用了不等式 $ e \le n(n-1)/2$ , 对于任意简单图来说这个不等式都成立。）

  

* **宽度优先搜索**   可以通过使用宽度优先搜索来产生简单图的生成树。同样，将构造一个有根树，而这个有根树的基本无向图就形成了生成树。从图的顶点中任意地选择一个根。然后添加与这个顶点 相关联的所有边。在这个阶段所添加的新顶点成为生成树在第1层上的顶点。将新顶点任意排序。下一步，按顺序访问第1层上的每个顶点，只要不产生简单回路，就将与这个顶点相关联的每条边添加到树中。任意排序第一层的每个顶点的孩子。这样就产生了树在第2层上的顶点。遵循相同的过程，直到已经添加了树中的所有顶点。因为在图中的边数是有限的，所以这个过程会终止。在产生了包含图中每一个顶点的树之后，生成树也就产生了。

  ```
  procedure BFS（G：带顶点 v1, ... , vn 的连通图） 
  T := 只包含顶点v1的树
  L := 空表
  把 v1 放入尚未处理顶点的表L中
  while L非空
      删除 L 中第一个顶点 v
      for v 的每个邻居 w
          if w 既不在 L 中也不在 T 中 then
              加入w到表L的末尾
              加入w和边｛v，w｝到T
  ```

* 分析宽度优先搜索的计算复杂度。对于图中的每个顶点 v 来说，检査所有与v 相邻的顶点并加入每个尚未访问过的顶点到树T中。假设图的邻接表是可用的，确定哪些顶点与给定顶点相邻就不需要任何计算。如同在深度优先搜索算法的分析中那样，我们**检查每条边至多两次来确定是否应当加入这条边及其尚未在树中的端点**。所以宽度优先搜索算法使用 $O(e)$ 或 $O(n^2)$ 个步骤。
  * 求图的连通分支的算法
  * 判断图是否是二分图的算法
  * 求图中两个顶点之间具有 最少边数的通路的算法

* **回溯的应用**   有些问题只能通过执行对所有可行解的穷举搜索来解决。
  * 系统地搜索出一个解的一种方式是**使用决策树**，其中每个内点都表示一次决策，而每个树叶都表示一个可行解。为了通过回溯来求出一个解，首先**尽可能地做出一系列决策来尝试得出一个解。可以用决策树里的通路来表示决策序列。一旦知道了决策序列的任何扩展都不能得出解，就回溯到父母顶点并且若有可能，则用另一个决策序列来尝试得出一个解.继续这个过程，直到找到一个解，或者证明没有解存在为止。**
  * **图着色**   如何用回溯来判定是否可以用n种颜色给一个图着色
    * 首先选择某个顶点a并且指定它的颜色为1。 然后挑选第二个顶点 b , 而且若b不与a相邻，则指定它的颜色为1。否则，指定b的颜色为2。 然后来到第三个顶点c。若有可能，则对c用颜色1。否则若有可能，则用颜色2。只有当颜色 1和颜色2都不能用时才使用颜色3。继续这个过程，只要有可能就为每个新顶点指定n种颜 色中的一种，而且总是使用表中第一种允许的颜色。若遇到不能用n种颜色中任何一种来着色的顶点时，则回溯到最后一次所指定的顶点，并且若有可能就用表中下一种允许的颜色改变最后着色的顶点的颜色。若不可能改变这个颜色，则再回溯到更前面指定的顶点，一次后退一 步，直到有可能改变一个顶点的颜色为止。然后只要有可能就继续指定新顶点的颜色。若使用 n 种颜色的着色存在，则可以通过回溯来产生（但是这个过程是极其低效的）。
  * **n皇后问题**  在 $n* n$ 棋盘上如何放置 n 个皇后，使得没有两个皇后可以互相攻击。如何用回溯来解决n皇后问题
  * **子集之和**   给定一组正整数 $x_1, x_2, ..., x_n$ 的集合，求这组整数的集合的一个子集，使其和为M
* **有向图中的深度优先搜索**    可以轻而易举地修改深度优先搜索和宽度优先捜索，使得以有向图作为输入时它们也能运行。但是，输岀不一定是生成树，而可能是森林。在这两个算法中，**只有当一条边从正在访问的顶点出发并且到一个尚未加入的顶点时才加入这条边**。**如果在其中任何一个算法的某个阶段找不到从已经加入的顶点到尚未加入的顶点的边，则算法加入的下一个顶点成为生成森林中一个新树的根。**
* **网络蜘蛛**  为了给网站建立索引，Google和Yahoo等著名的搜索引擎从已知的 网站开始系统地探索网络。这些搜索引擎使用所谓的网络蜘蛛（或网络爬虫、网络机器人） 的程序来访问网站并且分析其内容。网络蜘蛛同时使用深度优先搜索和宽度优先搜索来创建索引。 
  * 可以用所谓的网络图的有向图来为网页和网页之间的链接建立模型。用顶点表示网页，用有向边表示链接。
  * 利用深度优先搜索，选择一个初始的网页，沿着一个链接（如果存在这样的链接的话）到达第二个网页，沿着第二个网页的一个链接（如果存在这样的链接）到达第三个网页，等等，直到找到一个没有新的链接的网页为止。然后使用回溯来检查前面阶段的链接去寻找新的链接，等等。（由于实际限制，网络 蜘蛛在深度优先搜索中的搜索深度是有限的。）
  * 利用宽度优先搜索，选择一个初始的网页并且沿着这个网页上的一个链接到达第二个网页，然后沿着初始网页上的第二个链接（如果存在），以此类推，直到已经走过了初始网页上的所有链接为止。然后逐页地沿着下一层 网页上的链接，以此类推。

---

##### 最小生成树算法

* **连通加权图的最小生成树是具有边的权之和最小的生成树。**

* **普林（Prim）算法**   首先，选择带最小权的边，把它放进生成树里。依次向树里添加与已在树里的顶点关联的且不与已在树里的边形成简单回路的权最小的边。当已经添加了  n-1 条边时就停止。

  ```
  procedure Prim（G :带n个顶点的连通加权无向图）
  T := 权最小的边
  for i := 1 to n — 2
  	e := 与T里顶点关联且若添加到T里则不形成简单回路的权最小的边 
  	T := 添加e之后的T
  return T｛T是G的最小生成树｝
  ```

* **克鲁斯卡尔算法**   依次添加不与已经选择的边形成简单回路的权最小的边。在已经挑选了 n -1 条边之后就停止。

  ```
  procedure Kruskal (G:带n个顶点的加权连通无向图) 
  T :=空图
  for i := 1 to n — 1
      e := G中权最小的任一边且当添加到T里时不形成简单回路边 
      T := T添加e
  return T {T是G的最小生成树}
  ```

* 普林算法与克鲁斯卡尔算法的区别 (是否必须与当前生成树中节点相关联的边)
  * 在普林算法里，选择与已在树中的一个顶点相关联且不形成回路的权最小的边；
  * 在克鲁斯卡尔算法里，选择不一定与已在树中的一个顶点相关联且不形成回路的权最小的边。
* 可以证明， 为了求出具有 m 条边和 n 个顶点的图的最小生成树，克鲁斯卡尔算法需要用 $O(mlogm)$ 次运算来完成，而普林算法需要用次$O(mlogn)$运算来完成。因此，对于稀疏图来说，使用克鲁斯卡尔算法更好。在稀疏图中，m远远小于$C(n,2) = n(n-1)/2$, 即具有n个顶点的无向图的可能的总边数。否则，这两个算法的复杂度没有什么差别。